# 25.오늘의 1달러가 내일의 1달러보다 크다
- 다음과 같은 두가지 이슈 존재
    - 시점: 시기를 놓치면 가치가 떨어짐
    - 확실성: 현재 명확한 이점이 아니면 미래에 대해 불확실할 수 있음
- 돈의 시간 가치는 코드 정리를 나중에 하는 것을 권장 -> 비즈니스 가치 우선
    - 비용이 '선 코드 정리 + 후 동작 변경'이 '동작 변경' 보다 적으면 선 코드 정리
# 26.옵션
- 가치에 대한 예측이 불 확실할수록 바로 구현하는 것보다 옵션이 지닌 가치가 더 커짐 -> 변화 포용
- 소프트웨어 설계는 변화를 위한 준비로 동작 변경에 대한 준비
    - 내일의 동작 변경을 구매하는 옵션에 대해 지불하는 프리미엄
- 소프트웨어 설계를 옵션의 관점에서 생각
    - 잠재적인 동작 변경의 가치가 변동성이 클수록 좋음
    - 개발 기간이 길면 길수록 좋음
    - 앞으로 더 저렴하게 개발할 수 있다면 더 좋음
    - 더 작은 설계 작업으로 옵션을 만들 수 있다면 좋음

# 27.옵션과 현금흐름 비교
- 해당 책은 '선 코드 정리'에 대해 경제적 줄다리기 진행 중
  - 현금흐름할인: 먼저 돈을 벌고, 나중에 돈을 쓰기 -> 선 동작 변경, 후 코드 정리
  - 옵션: 나중에 더 많은 돈을 벌기 위해 지금 돈 쓰기 -> 선 코드 정리, 후 동작 변경
- 코드 정리를 선행해야하는 걸까? 그럴수도 있고, 아닐수도 있음
  - 선 코드 정리해야할 때: 비용(선 코드 정리) + 비용(후 동작 변경) < 비용(선 동작 변경)
  - 판단 필요할 때: 비용(선 코드 정리) + 비용(후 동작 변경) > 비용(선 동작 변경)
    - 단기적인 경제성 때문에 후 코드 정리가 필요함
    - 창출된 옵션의 가치가 더 빨리 그리고 확실하게 돈을 지출함으로써 읽는 가치보다 크다면 선 코드 정리 가능
    - 설계는 인관관계 속에서 벌어지는 활동이므로, 선 코드 정리하면 이후의 행동 변화가 더 즐거워지면 선 코드 정리 가능
- 몇분에서 몇 시간에 이르는 코드 정리 규모에서 코드 정리의 경제성을 정확하게 계산할수 없으며, 계산 시도를 하려고 하면 안됨
- 두가지 중요한 형태의 판단력을 길러 나중에 더 큰일을 실행
  - 소프트웨어 설계의 시기와 범위에 영향을 미치는 인센티브를 인식하는데 익숙해지기
  - 대인 관계 기술을 우리 자신에게 연습해서 동료부터 더 넓은 범위의 동료에게까지 활용하기

# 28.되돌릴 수 있는 구조변경
- 선행 코드 정리 특징: 구조 변경은 되돌릴수 있음 <-> 동작 변경은 되돌릴수 없음(잘못된 영향 발생)
- 되돌릴수 없는 결정과 되돌릴수 있는 결정은 다르게 취급되어야 함 -> 되돌릴수 없는 결정은 면밀히 검토 필요
- 소프트웨어 설계 결정은 쉽게 되돌릴수 있고, 동작 변경을 쉽게할 수 있는 장점 -> 되돌릴수 없는 결정과 같은 지나친 노력은 할필요 없음
- 코드 검토 절차는 되돌릴수 있는 변경 사항과 되돌릴수 없는 변경 사항을 구분하지 않음 -> 되돌릴수 있는 결정과 없는 결정을 구분하지 못하는 이슈
- 되돌릴수 없는 변경을 되돌릴 수 있는 변경을 활용하여 위험성을 줄임

# 29. 결합도
- 한 요소를 변경하려면 다른 요소도 변경해야하는 변경 감영 특성
```
caller()
  called()

called() // 이 이름을 변경하면 호출하는 코드도 변경해야 합니다.
      ...// 함수 본문 형식을 변경해도 호출하는 코드 변경할 필요가 없습니다.
```
- 결합도가 의미를 지니려면, 어떤 변경 사항과 관련하여 결합되었는지를 말해야 함 -> 일어나지 않는 변화와 관련하여 결합되어 있으면 의미가 없음
- 결합도 분석은 먼저 어떤 변경이 발생했거나 발생할 가능성이 있는지 확인 필요
- 결합도는 소프트웨어 비용을 결정함
- 결합도가 가진 두가지 특성
  - 일대다: 어떤 변경이 일어나면, 여러 요소화 결합이 일어남
    - 개발 도구를 이용하면 어느정도 해결 가능
  - 연쇄작용: 변경이 일어나면 다른 요소로 변경이 파급되고, 또다른 변경을 촉발함
    - 해당 문제가 큰 문제
    - 변경 비용은 멱법칙 분포를 따름 -> 연쇄적인 변경 비용때문에 발생
- 시스템이 복잡하다는건 변화가 예상치 못한 결과를 초래 -> 결합도가 높기 때문에
- 결합도는 소프트웨어 비용을 좌우하기에 결합도를 줄일수 있는 방법을 고민해봐야함

# 30. 콘스탄틴의 등가성
- 소프트웨어 설계의 목표는 소프트웨어 비용 최소화 -> 개발 비용의 70% 이상이 유지보수에 들어감
- '콘스탄틴의 등가성': 비용(소프트웨어) ~= 비용(변경)
- 출시 후 비용 증가되는 이유는? 변경과 함께 기존 시스템과의 마찰도 함께 일어남(호환성 및 운영 서버 안전성 등 고려)
- 멱법칙 분포에 의해 '비용(전체 변경) ~= 비용(큰 변경들)' 이라고 봐도 무방
- 큰 변경들의 비용이 비싼 이유는? 변경에 따른 전파가 매우 심하며 이를 결합도라함
- 비용(소프트웨어) ~= 비용(전체 변경) ~= 비용(큰 변경들) ~= 결합도 -> 비용(소프트웨어) ~= 결합도

# 31. 결합도와 결합도 제거
- 결합도는 평소에는 잘 보이지 않다가 동작 변경하려다가 곧 알아차리게 됨 -> 직접 마주치기 전까지는 깨닫기 어려움
- 시스템 결합도 존재 이유
  - 현금 흐름 할인(선 동작 변경)은 결합도 생성
  - 이전에는 문제가 되지 않았다고 판단
  - 어떤 결합도는 피할수 없음 -> 확신에 찬 단언
- 결합도가 왜 있는지는 중요하지 않고, 결합도 비용을 지불할 것인지 아니면 결합도를 없애는 비용을 지불할 것인지가 더 중요
- 한 종류의 코드 변경에 대한 결합도를 줄일수록 다른 종류의 코드 변경에 대한 결합도는 커짐 -> 모든 결합을 다 색출하듯 없애려고 애쓰지 말아야함
- 결합도에 따른 비용을 지불할 수도 있고, 결합도 제거 비용을 지불하고 이점(옵션)을 얻을 수 있음 -> 판단 과정에서 소프트웨어 설계가 어려운건 당연한거임

# 32. 응집도
- 응집도 의미
  - 결합된 요소들은 둘을 포함하는 같은 요소의 하위 요소
  - 거름이 아닌 이물질(결합되지 않은 요소)은 이 더미가 아닌 다른 곳으로 이동해야 한다는 것
- 응집도를 높이는 방법
  - 결합된 요소를 자체 하위 요소로 묶는 것
  - 결합되지 않은 요소를 가져와 다른 곳에 배치하는 것
- 즉흥적으로 시도하지 말기 -> 불완전하고 변화하는 정보를 가지고 작업하지 않고, 한 번에 한 요소씩 이동
- 모두가 스카우트 규칙('찾았을 때보다 더 나은 상태로 남겨두라')을 따른다면, 더 좋은 코드가 될 것

# 33. 결론
- 선 코드 정리에 대한 답은 다음 4가지 힘에 영향을 받음
  - 비용: 코드를 정리하면 비용이 줄까? 나중에 하는 편이 나을까?
  - 수익: 코드를 정리하면 수익이 더 커질까? 혹은 더 빨리 발생하거나 커질 가능성은 있나?
  - 결합도: 코드를 정리하면 변경에 필요한 요소의 수가 줄어드나요?
  - 응집도: 코드를 정리하면 변경을 더 작고 좁은 범위로 집중시켜 더 적은 수의 요소만 다룰수 있나요?
- 코드 정리에 너무 집작하지 말기 -> 코드 정리를 통해 자신의 삶과 업무가 나아질수 있다는 것이 중요
- 코드 정리가 필요하다면 먼저하는게 좋음