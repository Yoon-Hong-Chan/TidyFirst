# 7. 선언과 초기화를 함께 옮기기
- 보통 변수 이름에서 힌트를 얻기도 하지만 변수 초기화는 이름이 주는 의미를 더 강화 시킴
- 타입이 포함된 선언과 초기화 코드가 떨어져 있으면 읽기 어려움 -> 한참 뒤에 보면 어떤 맥락에서 선언되었는지 잊음
```
fn()
  int a
  ... 변수 a를 사용하지 않은 코드
  a = ...
  int b
  ... 변수 a를 사용할 수 있으나 변수 b를 사용하지 않는 코드
  b = ...a...
  ... 변수 b를 사용하는 코드
```
- 초기화를 변수 선언 근처로 이동하면 위에 이슈 해결
```
fn()
  int a = ...
  ... 변수 a를 사용하지 않은 코드
  ... 변수 a를 사용할 수 있으나 변수 b를 사용하지 않는 코드
  int b = ...a...
  ... 변수 b를 사용하는 코드
```

# 8. 설명하는 변수
- 코드의 어떤 표현식들은 계속 성장함 -> 나중엔 유심히 봐야 무슨 내용인지 알게 0되는 경우도 존재
- 어렵게 크고 복잡한 코드의 표현식을 일부를 추출하여 변수로 만들어 할당하는게 좋음
```
return new Point(
    ...긴 표현식...,
    ...다른 긴 표현식...
)
```
- 다음과 같이 변경 가능
```
x := ...긴 표현식...
y := ...다른 긴 표현식...
return new Point(x,y)
```

# 9. 설명하는 상수
- 코드를 읽다가 모르는 숫자를 볼때가 있음 -> 상징적 상수를 만들자
```
if response.code = 404
    ... 코드 ...
```
- 아래와 같이 변경하는 것이 의미 전달에 좋음
```
PAGE_NOT_FOUND := 404
if response.code = PAGE_NOT_FOUND
    ... 코드 ...
```
- 아래와 같이 빈약한 의미를 가진 상수는 좋지 않음 -> 다른 곳에서 오용될 수 있음
```
ONE = 1
... ONE ... #하나가 필요할 때 어디든 등장
```
- 한번 바뀌거나 함께 이해해야 하는 상수들은 한곳에 모아두는 것도 좋은 방법

# 10. 명시적인 매개변수
- 루틴에서 다루는 일부 데이터가 명시적으로 전달되지 않으면? 루틴을 나누자. 앞부분에서 매개변수 값을 채운 후, 뒷부분에서 명시적으로 전달
- 아래와 같이 매개변수를 map을 사용하여 어떤 데이터가 필요한지 알기가 어려움 -> 끔찍한 남용의 길이 열림
```
params = { a: 1, b: 2}
foo(params)

function foo(params)
    ...params.a... ...params.b...
```
- 아래와 같이 foo를 나누면 매개변수 정리가 가능
```
function foo(params)
    foo_body(params.a, params.b)
function foo_body(a,b)
    ...a... ...b...
```
### 이해 포인트
- 매개변수를 명시하기 위해 기존 foo 로직에서 foo_body로 wrapping 함


# 11. 비슷한 코드끼리
- 긴 코드 정어리를 읽다가 구분이 되는 부분에 대해 빈 줄을 넣어 분리함
- 적절한 소프트웨어 설계는 변화를 가능하게 함
  - 소프트웨어 설계가 큰일이 되면? -> 설계 작업이 힘들어져 그만두고 싶어지는 이슈 발생
- 관련 있는 코드를 뭉쳐두면 다양한 길로 나아갈 수 있음
### 이해 포인트
- 소프트웨어의 유연성을 확보하여 변화가 가능하게 하자 -> 그 중 하나가 비슷한 코드끼리 뭉쳐놓는거

# 12. 도우미 추출(헬퍼 메소드)
- 코드를 보면 목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 -> 코드 블록을 추려내고, 도우미로 추출한 후 이름을 붙임
- 코우미 이름은 작동 방식이 아니라 목적에 따라 지음
### 큰 루틴 안에서 몇 줄을 변경해야 하는 경우
- 아래와 같은 경우
```
routine()
    ...그대로 두는 코드...
    ...바꾸려는 코드...
    ...그대로 두는 코드...
```
- 이렇게 바꿈
```
helper()
    ...바꾸려는 코드...
routine()
    ...그대로 두는 코드...
    helper()
    ...그대로 두는 코드...
```
- 해당 작업은 응집도 높은 요소 만들기로 이해하게 됨

### 시간적 결합을 표현하는 경우(a()가 b()보다 앞서 호출되어야 하는 경우)
- 다음과 같은 코드
```
foo.a()
foo.b()
```
- 이럴 때는 다음처럼 변경
```
ab()
    a()
    b()
```

- 도우미는 재사용 욕구를 일으킴 -> 인터페이스 사용을 이끄는 도구가 됨
